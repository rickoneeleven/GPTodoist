# File: helper_timesheets.py (Imports Only)
import os # <<< ADDED: For os.environ.get
import random
from datetime import datetime, timedelta
from typing import Union, List, Dict, Optional
from rich import print
from todoist_api_python.api import TodoistAPI

# Import specific functions/modules needed
import module_call_counter
import helper_todoist_long
import helper_todoist_part2
import state_manager
import helper_diary # <<< ADDED: For OBJECTIVE_LOOKBACK_DAYS constant

# --- Constants ---
# <<< REMOVED: Filename constants >>>
# <<< KEPT: Application logic constants >>>
DEFAULT_TASK_DURATION = 5
DEFAULT_RAND_LOW = 420 # 7 hours
DEFAULT_RAND_HIGH = 480 # 8 hours

# --- Helper Functions ---

# <<< REMOVED: _load_json function >>>
# <<< REMOVED: _save_json function >>>

def prompt_user(message: str) -> str:
    """Displays a formatted prompt and gets user input. (No changes needed)"""
    # Using simple input for robustness, rich print only for display
    print(f"[bold bright_magenta]{message}[/bold bright_magenta]", end=" ")
    return input()

def get_timesheet_date() -> Optional[datetime.date]:
    """Gets and validates the timesheet date from user input. (No changes needed)"""
    retries = 3
    for _ in range(retries):
        try:
            date_input = prompt_user("Timesheet date? (dd/mm/yy, Enter=yesterday):").strip()
            if not date_input or date_input.lower() == 'yesterday':
                return datetime.now().date() - timedelta(days=1)
            return datetime.strptime(date_input, "%d/%m/%y").date()
        except ValueError:
            print("[yellow]Invalid date format. Please use dd/mm/yy or press Enter for yesterday.[/yellow]")
    print("[red]Too many invalid date attempts.[/red]")
    return None

def load_and_filter_tasks(timesheet_date: datetime.date) -> list:
    """Loads completed tasks via state_manager, filters by date, sorts, and re-indexes for display."""
    # <<< MODIFIED: Use state_manager >>>
    all_tasks = state_manager.get_completed_tasks_log()
    # State manager already handles invalid file format, returns list

    date_tasks = []
    parse_error_count = 0 # Keep track locally for info, though state manager might log too

    for task in all_tasks:
        # State manager ensures list, but entries could still be invalid dicts internally
        if not isinstance(task, dict):
            # print(f"[yellow]Skipping invalid entry in completed tasks: {task}[/yellow]") # Less verbose
            continue # Skip non-dict items found in the list

        datetime_str = task.get('datetime')
        if not isinstance(datetime_str, str):
            # print(f"[yellow]Skipping task with missing/invalid datetime: {task.get('task_name', 'N/A')}[/yellow]") # Less verbose
            continue

        try:
            task_datetime = datetime.strptime(datetime_str, "%Y-%m-%d %H:%M:%S")
            if task_datetime.date() == timesheet_date:
                date_tasks.append(task)
            # else: task belongs to another date, ignore for this function
        except ValueError:
            parse_error_count += 1
            # Don't add task with parse error to date_tasks

    if parse_error_count > 0:
        print(f"[yellow]Warning: Could not parse datetime for {parse_error_count} tasks while filtering for timesheet.[/yellow]")

    # Sort tasks for the specific date by datetime
    try:
        date_tasks.sort(key=lambda x: datetime.strptime(x.get('datetime', ''), "%Y-%m-%d %H:%M:%S") if isinstance(x.get('datetime'), str) else datetime.min)
    except ValueError:
         print("[yellow]Warning: Error sorting tasks by datetime due to format issues. Order may be incorrect.[/yellow]")


    # Re-index the tasks for the specific date (1-based index) for display/selection only
    # This 'id' is temporary for the current timesheet session
    for i, task in enumerate(date_tasks):
        task['id'] = i + 1 # Add/Update temporary 'id'

    # Note: We are NOT saving the re-indexed tasks back to the main log here.
    # The original log keeps its persistent IDs generated by the state_manager.

    return date_tasks # Return only the filtered, sorted, temporarily indexed tasks for the specified date


def display_tasks_for_selection(tasks: list):
    """Displays the filtered tasks for the user to select. (No changes needed)"""
    if not tasks:
        print("\n[yellow]No completed tasks found for the selected date.[/yellow]")
        return

    print("\n[cyan]Completed tasks for selection:[/cyan]")
    for task in tasks:
         # Use the temporary 'id' assigned in load_and_filter_tasks
         task_id = task.get('id', '?')
         task_dt = task.get('datetime', '?:??')
         task_name = task.get('task_name', 'Unknown Task')
         # Show time part only for brevity
         time_part = task_dt.split(' ')[-1] if ' ' in task_dt else task_dt
         print(f"  ID: {task_id}, Time: {time_part}, Task: {task_name}")


def get_selected_task_ids(filtered_tasks: list) -> list[int]:
    """Gets and validates task IDs (temporary display IDs) from user input. (No changes needed)"""
    if not filtered_tasks:
        return [] # No tasks to select

    # Use the temporary 'id' for validation
    valid_ids = {task.get('id') for task in filtered_tasks if isinstance(task.get('id'), int)}
    if not valid_ids:
        print("[yellow]No tasks with valid IDs available for selection.[/yellow]")
        return []

    while True:
        try:
            id_input = prompt_user("Enter task IDs for timesheet (comma-separated, Enter=skip):").strip()
            if not id_input:
                return []

            selected_ids = []
            raw_ids = [id_str.strip() for id_str in id_input.split(',') if id_str.strip()]
            all_valid = True
            for id_str in raw_ids:
                 num_id = int(id_str)
                 if num_id in valid_ids:
                     selected_ids.append(num_id)
                 else:
                     print(f"[yellow]ID {num_id} is not a valid task ID for this date.[/yellow]")
                     all_valid = False

            if all_valid:
                 # Remove duplicates while preserving order
                 return list(dict.fromkeys(selected_ids))
            # If not all valid, loop continues

        except ValueError:
            print("[yellow]Invalid input. Please enter numbers separated by commas.[/yellow]")


def get_task_details_from_user(task: dict) -> Optional[dict]:
    """Gets updated summary and duration for a selected task. (No changes needed)"""
    original_summary = task.get('task_name', 'Unknown Task')
    # Use temporary ID for display
    print(f"\nProcessing Task ID {task.get('id', '?')}: [white]{original_summary}[/white]")

    # Get task summary
    new_summary = original_summary
    change_summary = prompt_user("Change summary? (y/N):").strip().lower()
    if change_summary == 'y':
        entered_summary = prompt_user("Enter new summary:").strip()
        if entered_summary: # Only update if something was entered
             if any(char.isdigit() for char in entered_summary):
                 confirm_change = prompt_user(f"[red]New summary '{entered_summary}' contains numbers. Confirm? (y/N):[/red]").strip().lower()
                 if confirm_change == 'y':
                     new_summary = entered_summary
                 else:
                     print("[yellow]Summary change cancelled.[/yellow]")
             else:
                 new_summary = entered_summary
        else:
             print("[yellow]No new summary entered, keeping original.[/yellow]")


    # Get task duration
    while True:
        try:
            duration_input = prompt_user(f"Time spent in minutes? (Enter={DEFAULT_TASK_DURATION}, wrap in () to lock):").strip()
            is_locked = False
            if duration_input.startswith('(') and duration_input.endswith(')'):
                is_locked = True
                duration_input = duration_input[1:-1].strip() # Get value inside parentheses

            if not duration_input:
                duration = DEFAULT_TASK_DURATION
            else:
                duration = int(duration_input)

            if duration <= 0:
                print(f"[yellow]Duration must be positive. Using default {DEFAULT_TASK_DURATION}.[/yellow]")
                duration = DEFAULT_TASK_DURATION

            # Return collected details
            return {
                "summary": new_summary,
                "duration": duration,
                "is_locked": is_locked,
                "datetime": task.get('datetime') # Keep original datetime for sorting
            }
        except ValueError:
            print("[yellow]Invalid number entered for duration.[/yellow]")


def get_additional_task_details(timesheet_date: datetime.date) -> Optional[dict]:
    """Gets details for tasks added manually. (No changes needed)"""
    print("\nAdding additional task...")
    summary = prompt_user("Enter task summary:").strip()
    if not summary:
        print("[yellow]Task summary cannot be empty. Skipping additional task.[/yellow]")
        return None

    # Get duration
    while True:
        try:
            duration_input = prompt_user(f"Time spent in minutes? (Enter={DEFAULT_TASK_DURATION}, wrap in () to lock):").strip()
            is_locked = False
            if duration_input.startswith('(') and duration_input.endswith(')'):
                is_locked = True
                duration_input = duration_input[1:-1].strip()

            if not duration_input:
                duration = DEFAULT_TASK_DURATION
            else:
                duration = int(duration_input)

            if duration <= 0:
                print(f"[yellow]Duration must be positive. Using default {DEFAULT_TASK_DURATION}.[/yellow]")
                duration = DEFAULT_TASK_DURATION
            break # Exit duration loop
        except ValueError:
            print("[yellow]Invalid number entered for duration.[/yellow]")

    # Get completion time
    while True:
        completion_time_str = prompt_user("Completion time? (HH:mm format):").strip()
        try:
            completion_time = datetime.strptime(completion_time_str, "%H:%M").time()
            task_datetime = datetime.combine(timesheet_date, completion_time)
            datetime_str = task_datetime.strftime("%Y-%m-%d %H:%M:%S") # Ensure seconds are included
            break # Exit time loop
        except ValueError:
            print("[yellow]Invalid time format. Please use HH:mm (e.g., 14:30).[/yellow]")

    return {
        "summary": summary,
        "duration": duration,
        "is_locked": is_locked,
        "datetime": datetime_str # Store formatted string
    }

def get_random_target_duration() -> int:
    """Gets random range, calculates target duration (multiple of 5). (No changes needed)"""
    while True:
        try:
            low_input = prompt_user(f"Target minutes range - low? (Enter={DEFAULT_RAND_LOW}):").strip()
            rand_low = int(low_input) if low_input else DEFAULT_RAND_LOW

            if rand_low < 0:
                print("[yellow]Low value cannot be negative.[/yellow]")
                continue

            high_input = prompt_user(f"Target minutes range - high? (Enter={DEFAULT_RAND_HIGH}):").strip()
            rand_high = int(high_input) if high_input else DEFAULT_RAND_HIGH

            if rand_high <= rand_low:
                print("[yellow]High value must be greater than low value.[/yellow]")
                continue

            # Generate random duration and round to nearest 5 minutes
            target = random.randint(rand_low, rand_high)
            target_duration = round(target / 5) * 5
            print(f"[cyan]Target total duration: {target_duration} minutes ({target_duration/60:.2f} hours).[/cyan]")
            return target_duration

        except ValueError:
            print("[yellow]Invalid number entered. Please enter integers.[/yellow]")


def adjust_durations(timesheet_entries: list, target_duration: int) -> list:
    """Adjusts unlocked task durations to meet the target total duration. (No changes needed)"""
    locked_duration = sum(entry['duration'] for entry in timesheet_entries if entry.get('is_locked'))
    unlocked_entries = [entry for entry in timesheet_entries if not entry.get('is_locked')]
    unlocked_duration = sum(entry['duration'] for entry in unlocked_entries)
    current_total = locked_duration + unlocked_duration

    if not unlocked_entries:
        if current_total != target_duration:
             print(f"[yellow]All tasks are locked. Total duration ({current_total}m) may not match target ({target_duration}m).[/yellow]")
        return timesheet_entries # No unlocked tasks to adjust

    needed_adjustment = target_duration - current_total
    if needed_adjustment == 0:
        return timesheet_entries # Already at target

    # --- Adjustment Logic ---
    step = 5 if needed_adjustment > 0 else -5
    remaining_adjustment = abs(needed_adjustment)

    while remaining_adjustment > 0:
        adjusted_this_round = False
        # Iterate through unlocked tasks to apply adjustment step
        for entry in unlocked_entries:
            if remaining_adjustment <= 0: break

            # Check if adjustment is possible (don't make duration <= 0 when subtracting)
            if step < 0 and entry['duration'] <= abs(step):
                continue # Cannot subtract from this task

            entry['duration'] += step
            remaining_adjustment -= abs(step)
            adjusted_this_round = True

        # If no tasks could be adjusted in a round, break to prevent infinite loop
        if not adjusted_this_round:
            print("[yellow]Warning: Could not fully adjust durations to target (tasks may be too short).[/yellow]")
            break

    # Verify final total (for debugging/info)
    final_total = sum(entry['duration'] for entry in timesheet_entries)
    if final_total != target_duration: # Check difference even if remaining_adjustment is 0 due to step size
         print(f"[yellow]Final adjusted duration ({final_total} mins) differs from target ({target_duration} mins).[/yellow]")
    elif final_total == target_duration and needed_adjustment != 0: # Only print success if adjustment actually happened
         print("[green]Durations adjusted successfully to meet target.[/green]")

    return timesheet_entries


def save_timesheet_to_diary(timesheet_entries: list, timesheet_date: datetime.date):
    """Formats and saves the timesheet entries into the diary file using state_manager."""
    # Prepare entries for saving (remove temporary keys)
    entries_to_save = []
    for entry in timesheet_entries:
        saved_entry = {
            "summary": entry.get('summary', 'Unknown Task'),
            "duration": entry.get('duration', 0)
            # 'datetime' and 'is_locked' are not saved to the diary entry
        }
        entries_to_save.append(saved_entry)

    total_duration = sum(entry['duration'] for entry in entries_to_save)
    total_hours = total_duration / 60

    timesheet_date_str = timesheet_date.strftime("%Y-%m-%d")

    # Create the data payload for the specific date's entry
    diary_update_payload = {
        "tasks": entries_to_save,
        "total_duration": total_duration,
        "total_hours": round(total_hours, 2)
        # Note: This will overwrite existing tasks/total_duration/total_hours for the day.
        # The objective for the day is preserved as state_manager.update_diary_entry merges.
    }

    # <<< MODIFIED: Use state_manager to update the diary entry >>>
    if state_manager.update_diary_entry(timesheet_date_str, diary_update_payload):
        print(f"\n[green]Timesheet for {timesheet_date_str} saved successfully.[/green]")
    else:
        print(f"\n[red]Failed to save timesheet for {timesheet_date_str}.[/red]")


def update_objective_for_today():
    """Handles displaying the last objective and prompting user to update today's, using state_manager."""
    today = datetime.now().date()
    today_str = today.strftime("%Y-%m-%d") # Needed? state_manager handles date internally

    # 1. Find and display the most recent objective via state_manager
    # <<< MODIFIED: Call state_manager >>>
    # Pass the lookback period defined in helper_diary (though ideally it's defined centrally)
    lookback = helper_diary.OBJECTIVE_LOOKBACK_DAYS # Reference constant from helper_diary
    last_objective, last_objective_date = state_manager.find_most_recent_objective(today, lookback_days=lookback)

    if last_objective:
        if last_objective_date: # Ensure date is valid
            days_ago = (today - last_objective_date).days
            day_word = "day" if days_ago == 1 else "days"
            date_str_formatted = last_objective_date.strftime('%A, %d %B') # Shortened format

            if days_ago == 0:
                print(f"\n[bold]Current Objective[/bold] (Set today):")
            else:
                print(f"\n[bold]Most Recent Objective[/bold] (Set {days_ago} {day_word} ago - {date_str_formatted}):")
            print(f"[yellow]{last_objective}[/yellow]")
        else: # Should not happen if state_manager returns objective, but safety check
             print(f"\n[bold]Current Objective[/bold] (Date Unknown):")
             print(f"[yellow]{last_objective}[/yellow]")
    else:
        print("\n[yellow]No recent objective found in diary.[/yellow]")
        last_objective = None # Ensure it's None if not found

    # 2. Ask user if they want to update (Default is YES)
    update_choice = prompt_user("Update objective for today? (Y/n):").lower().strip()

    new_objective_to_set = None # Start with None, only set if needed

    if update_choice != 'n': # Treat Enter or 'y' as yes
        entered_objective = prompt_user("Enter new objective for today:").strip()
        if entered_objective:
            new_objective_to_set = entered_objective
            # Message printed by state_manager on success
        else:
            print("[yellow]No new objective entered. Keeping previous objective (if any).[/yellow]")
            # Keep whatever objective is already set for today (or none)
    else: # User explicitly entered 'n'
         if last_objective:
              print("[cyan]Keeping the most recent objective.[/cyan]")
         else:
              print("[cyan]No objective will be set for today.[/cyan]")
         # Don't try to set a new objective

    # 3. Save the final objective (if one was decided upon) using state_manager
    if new_objective_to_set is not None:
        # <<< MODIFIED: Call state_manager >>>
        state_manager.update_todays_objective(new_objective_to_set)
        # Success/failure message handled by state_manager
    # If new_objective_to_set is None, we don't call the state manager, preserving today's state.

# --- Main Timesheet Function ---

def timesheet():
    """Main function orchestrating the timesheet creation process."""
    try:
        # Initialize API (still potentially needed for displaying tasks at the end)
        try:
            api_key = os.environ.get("TODOIST_API_KEY")
            if not api_key:
                 print("[red]TODOIST_API_KEY environment variable not set.[/red]")
                 return
            api = TodoistAPI(api_key)
        except Exception as api_init_error:
            print(f"[red]Failed to initialize Todoist API: {api_init_error}[/red]")
            return


        # 1. Get Date
        timesheet_date = get_timesheet_date()
        if not timesheet_date: return

        # 2. Load Data (using state_manager indirectly via load_and_filter_tasks)
        filtered_tasks = load_and_filter_tasks(timesheet_date)
        # <<< REMOVED: Direct loading of diary_data here, happens within save_timesheet_to_diary >>>

        # 3. Task Selection
        display_tasks_for_selection(filtered_tasks)
        selected_ids = get_selected_task_ids(filtered_tasks)

        # 4. Process Selected Tasks
        timesheet_entries = []
        # Map temporary ID to task dict from the filtered list
        task_map = {task.get('id'): task for task in filtered_tasks if isinstance(task.get('id'), int)}
        for task_id in selected_ids:
            task = task_map.get(task_id)
            if task:
                entry_details = get_task_details_from_user(task)
                if entry_details:
                    timesheet_entries.append(entry_details)

        # 5. Process Additional Tasks
        while True:
            add_more = prompt_user("Add another task manually? (y/N):").lower().strip()
            if add_more == 'y':
                additional_entry = get_additional_task_details(timesheet_date)
                if additional_entry:
                    timesheet_entries.append(additional_entry)
                    lock_status = "(locked)" if additional_entry.get('is_locked') else ""
                    print(f"  Added: {additional_entry['summary']} ({additional_entry['duration']} mins) {lock_status}")
            else:
                break

        if not timesheet_entries:
            print("[yellow]No tasks selected or added. Timesheet process aborted.[/yellow]")
            return

        # 6. Sort Entries by Time (using original datetime preserved)
        try:
            timesheet_entries.sort(key=lambda x: datetime.strptime(x.get('datetime', ''), "%Y-%m-%d %H:%M:%S") if isinstance(x.get('datetime'), str) else datetime.min)
        except ValueError:
             print("[yellow]Warning: Error sorting timesheet entries by datetime. Order may be incorrect.[/yellow]")

        # 7. Adjust Durations
        target_duration = get_random_target_duration()
        timesheet_entries = adjust_durations(timesheet_entries, target_duration)

        # 8. Display Final Timesheet
        print("\n[bold green] --- Final Timesheet --- [/bold green]")
        total_duration = 0
        for entry in timesheet_entries:
            lock_status = "[red](locked)[/red]" if entry.get('is_locked') else ""
            summary = entry.get('summary', 'Unknown Task')
            duration = entry.get('duration', 0)
            print(f"  {summary}: {duration} minutes {lock_status}")
            total_duration += duration
        total_hours = total_duration / 60
        print(f"\nTotal Time: {total_duration} minutes ({total_hours:.2f} hours)")
        print("[bold green]-------------------------[/bold green]")

        # 9. Save Timesheet (Uses state_manager internally)
        save_timesheet_to_diary(timesheet_entries, timesheet_date)

        # 10. Display Long-Term Tasks (No change needed here)
        try:
            helper_todoist_long.display_tasks(api)
        except Exception as e:
            print(f"[red]Error displaying long-term tasks: {e}[/red]")

        # 11. Display Current Tasks (No change needed here)
        try:
            print("\n[cyan]Refreshing current Todoist tasks view...[/cyan]")
            helper_todoist_part2.display_todoist_tasks(api)
        except Exception as e:
            print(f"[red]Error displaying current Todoist tasks: {e}[/red]")

        # 12. Update Today's Objective (Uses state_manager internally)
        # <<< MODIFIED: No need to reload diary_data explicitly >>>
        update_objective_for_today()

    except Exception as e:
        print(f"\n[bold red]An unexpected error occurred during the timesheet process:[/bold red]")
        print(f"[red]{e}[/red]")
        # Log stack trace for debugging unexpected errors
        import traceback
        traceback.print_exc()

# Apply call counter decorator (No changes needed)
if 'module_call_counter' in globals() and hasattr(module_call_counter, 'apply_call_counter_to_all'):
     module_call_counter.apply_call_counter_to_all(globals(), __name__)
else:
     print("[yellow]Warning: module_call_counter not fully available in helper_timesheets.[/yellow]")